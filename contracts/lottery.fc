#include "imports/stdlib.fc";
;; сделать если вылетает ошибка возращать участнику сообщение
;; добавить децентрализацию, чтобы каждый мог запускать игру
;; добавить коммиссии для людей которые вызывают контракт 
;; также нужно добавить если 1 участник, то все деньги возращаются

;; написать в конце все гет методы


;; storage
global cell storage::list_participates; ;; ref
global int storage::jackpot; ;; 124
global slice storage::admin_address; ;; 267
global int storage::game_time; ;; 16
global int storage::min_bet; ;; 124
global int storage::max_bet; ;; 124
global int storage::max_participates; ;; 8
global int storage::participates_number; ;; 8 
;; global int storage::public_key; ;; 256
global int storage::commission_game_admin; ;; 16
global int storage::commission_game_runners; ;; 16
global int storage::stop_game_on_round; ;; 32 
global int storage::game_round; ;; 32
global int storage::game_start_time; ;; 32
global slice storage::last_winner_address; ;; 267
;; const 

;; errors 

;; op-codes

;; fifting 
tuple get_prev_block() asm "PREVKEYBLOCK";
(cell, (cell, int)) ~udict_add_get_ref?(cell dict, int key_len, int index, cell value) asm(value index dict key_len) "DICTUADDGETREF" "NULLSWAPIF";
(cell, int) udict_replace_ref?(cell dict, int key_len, int index, cell value) asm(value index dict key_len) "DICTUREPLACEREF";
(cell, (int, cell, int)) ~udict_delete_get_min_ref?(cell dict, int key_len) asm(-> 0 2 1 3) "DICTUREMMINREF" "NULLSWAPIFNOT2";

() load_data() impure inline {
    slice ds = get_data().begin_parse();  ;; Bits = 1 + 32 + 267 + 267 + 267 + 1 = 835. Refs = 3.
    storage::list_participates = ds~load_dict();
    storage::jackpot = ds~load_coins();
    storage::admin_address = ds~load_msg_addr();
    storage::game_time = ds~load_uint(16);
    storage::min_bet = ds~load_coins();
    storage::max_bet = ds~load_coins();
    storage::max_participates = ds~load_uint(8);
    storage::participates_number = ds~load_uint(8);
    storage::commission_game = ds~load_uint(16);
    storage::stop_game = ds~load_int(2);
    storage::game_number = ds~load_uint(32);
    storage::game_start_time = ds~load_uint(32);
    storage::last_winner_address = ds~load_msg_addr();
    ds.end_parse();
}


() save_data() impure inline {
    set_data(
        begin_cell()
            .store_dict(storage::list_participates)
            .store_coins(storage::jackpot)
            .store_slice(storage::admin_address)
            .store_uint(storage::game_time, 16)
            .store_coins(storage::min_bet)
            .store_coins(storage::max_bet)
            .store_uint(storage::max_participates ,8)
            .store_uint(storage::participates_number ,8)
            .store_uint(storage::commission_game ,16)
            .store_int(storage::stop_game ,2)
            .store_uint(storage::game_number ,32)
            .store_uint(storage::game_start_time ,32)
            .store_slice(storage::last_winner_address)
        .end_cell()
    );
}

() custom_randomize() impure inline {
    int prev_root_hash = 0;
    try {
        tuple prev_block = get_prev_block(); ;; (int wc, int shard, int seqno, int root_hash, int file_hash)
        prev_root_hash = prev_block.at(3);
    } catch (x, n) {
        prev_root_hash = 1;
    }

    randomize(prev_root_hash);
}



() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);

    if (flags & 1) { ;; ignore all bounced messages
        return ();
    }

    slice sender_address = cs~load_msg_addr();

    int op = 0;
    load_data();

    if (in_msg_body.slice_empty?() == false) {
        op = in_msg_body~load_op();
    }

    if (op == 0) { ;; проверка на ставку и на количество участников
        throw_if(666, storage::game_round == storage::stop_game_on_round);
        throw_if(777, (storage::min_bet > msg_value) | (storage::max_bet < msg_value));
        throw_if(888, storage::participates_number > storage::max_participates);

        var (_, key_addr) = parse_std_addr(sender_address);
        
        ;; добавить проверку на чейн

        var (value, found) = storage::list_participates~udict_add_get_ref?(256, key_addr, begin_cell().store_coins(msg_value).store_slice(sender_address).end_cell());

        if ( ~ found) {
            slice payload = value.begin_parse();
            int new_bet = payload~load_coins() + msg_value;
            storage::list_participates.udict_replace_ref?(256, key_addr, begin_cell().store_coins(new_bet).store_slice(sender_address).end_cell());
        } else {
            storage::participates_number += 1; 
        }

        storage::jackpot += msg_value;
        save_data();
        return ();
    }

    ;; admin part

    throw_unless(999, equal_slices_bits(sender_address, storage::admin_address));

    if (op == 1) { ;; stop game
        storage::stop_game_on_round = in_msg_body~load_uint(32);
        save_data();
        return ();
    }

    if (op == 2) { ;; change basic sittings 
        storage::game_time = in_msg_body~load_uint(16);
        storage::min_bet = in_msg_body~load_coins();
        storage::max_bet = in_msg_body~load_coins();
        storage::max_participates = in_msg_body~load_uint(8);
        storage::commission_game = in_msg_body~load_uint(16);
        storage::game_start_time = in_msg_body~load_uint(32);
        save_data();
        return ();
    }

    if (op == 3) { ;; change admin
        storage::admin_address = in_msg_body~load_msg_addr();
        save_data();
        return ();
    }

    if (op == 4) { ;; update code and data
        (cell new_data, cell new_code) = (in_msg_body~load_ref(), in_msg_body~load_ref());
        set_data(new_data);
        set_code(new_code);
        return ();
    }
}


() recv_external(slice in_msg_body) impure { ;; finish and start new game
    cell msg_inner = in_msg_body~load_ref();
    slice signature = in_msg_body~load_bits(512);
    in_msg_body.end_parse();
    int msg_inner_hash = msg_inner.cell_hash();

    load_data();

    throw_unless(7777, check_signature(msg_inner_hash, signature, storage::public_key));

    slice msg_inner_slice = msg_inner.begin_parse();  
    int game_number = msg_inner_slice~load_uint(32);

    throw_unless(222, game_number == storage::game_number);
    throw_if(666, storage::game_round == storage::stop_game_on_round);
    throw_unless(111, (storage::game_start_time + storage::game_time) <= now());

    accept_message();

    custom_randomize();
    randomize_lt();
    int r = rand(storage::jackpot);

    int flag = 0;
    int sum_bet = 0;

    do {
        var (_, value, _) = storage::list_participates~udict_delete_get_min_ref?(256);
        ~dump(value);
        slice payload = value.begin_parse();
        sum_bet += payload~load_coins();
        ~dump(sum_bet);
        if (r < sum_bet) {
            storage::last_winner_address = payload~load_msg_addr();
            flag = -1;
        }
    } until (flag == -1);

    ;; сначала отправляем деньги если есть валидатор 
    ;; потом отправляем деньги владельцам
    ;; финале отправляем деньги победителю 

    if (in_msg_body.slice_empty?() == false) {
        slice game_runner = msg_inner_slice~load_msg_addr();
        int commission_runner = muldiv(storage::jackpot, storage::commission_game_runners, 10000); ;; добавить константу 3.2% = 320
        storage::jackpot -= commission_runner;
        send_raw_message(msg,mode);
    }

    int commission_admin = muldiv(storage::jackpot, storage::commission_game_admin, 10000);
    send_raw_message(msg,mode);

    raw_reserve(5, 0); ;; 0.05 ton 
    send_raw_message(msg,mode);

    storage::list_participates = new_dict();
    storage::jackpot = 0;
    storage::max_participates = 0;
    storage::game_number += 1;
    storage::game_start_time = now();
    save_data();
}