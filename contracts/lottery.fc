#include "imports/stdlib.fc";
;; нужно продумать если один и тот же участник делает две ставки
;; сделать если вылетает ошибка возращать участнику сообщение 

;; storage
global cell storage::list_participates; ;; ref
global int storage::jackpot; ;; 124
global slice storage::admin_address; ;; 267
global int storage::game_time; ;; 16
global int storage::min_bet; ;; 124
global int storage::max_bet; ;; 124
global int storage::max_participates; ;; 8
global int storage::participates_number; ;; 8 
;; global int storage::public_key; ;; 256 ;; потом добавлю
global int storage::commission_game; ;; 16
global int storage::stop_game; ;; true = -1 or false = 0 ;; 2
global int storage::game_number; ;; 32
global int storage::game_start_time; ;; 32
global slice storage::last_winner_address; ;; 267
;; const 

;; errors 

;; op-codes

;; fifting 
tuple get_prev_block() asm "PREVKEYBLOCK";
(cell, (cell, int)) ~udict_add_get_ref?(cell dict, int key_len, int index, cell value) asm(value index dict key_len) "DICTUADDGETREF" "NULLSWAPIF";
(cell, int) udict_replace_ref?(cell dict, int key_len, int index, cell value) asm(value index dict key_len) "DICTUREPLACEREF";
(cell, (int, cell, int)) ~udict_delete_get_min_ref?(cell dict, int key_len) asm(-> 0 2 1 3) "DICTUREMMINREF" "NULLSWAPIFNOT2";

() load_data() impure inline {
    slice ds = get_data().begin_parse();  ;; Bits = 1 + 32 + 267 + 267 + 267 + 1 = 835. Refs = 3.
    storage::list_participates = ds~load_dict();
    storage::jackpot = ds~load_coins();
    storage::admin_address = ds~load_msg_addr();
    storage::game_time = ds~load_uint(16);
    storage::min_bet = ds~load_coins();
    storage::max_bet = ds~load_coins();
    storage::max_participates = ds~load_uint(8);
    storage::participates_number = ds~load_uint(8);
    storage::commission_game = ds~load_uint(16);
    storage::stop_game = ds~load_int(2);
    storage::game_number = ds~load_uint(32);
    storage::game_start_time = ds~load_uint(32);
    storage::last_winner_address = ds~load_msg_addr();
    ds.end_parse();
}


() save_data() impure inline {
    set_data(
        begin_cell()
            .store_dict(storage::list_participates)
            .store_coins(storage::jackpot)
            .store_slice(storage::admin_address)
            .store_uint(storage::game_time, 16)
            .store_coins(storage::min_bet)
            .store_coins(storage::max_bet)
            .store_uint(storage::max_participates ,8)
            .store_uint(storage::participates_number ,8)
            .store_uint(storage::commission_game ,16)
            .store_int(storage::stop_game ,2)
            .store_uint(storage::game_number ,32)
            .store_uint(storage::game_start_time ,32)
            .store_slice(storage::last_winner_address)
        .end_cell()
    );
}

() custom_randomize() impure inline {
    int prev_root_hash = 0;
    try {
        tuple prev_block = get_prev_block(); ;; (int wc, int shard, int seqno, int root_hash, int file_hash)
        prev_root_hash = prev_block.at(3);
    } catch (x, n) {
        prev_root_hash = 1;
    }

    randomize(prev_root_hash);
}



() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);

    if (flags & 1) { ;; ignore all bounced messages
        return ();
    }

    slice sender_address = cs~load_msg_addr();

    int op = 0;
    load_data();

    if (in_msg_body.slice_empty?() == false) {
        op = in_msg_body~load_op();
    }

    if (op == 0) { ;; проверка на ставку и на количество участников
        throw_if(666, storage::stop_game);
        throw_if(777, (storage::min_bet > msg_value) | (storage::max_bet < msg_value));
        throw_if(888, storage::participates_number > storage::max_participates);

        var (_, key_addr) = parse_std_addr(sender_address);
        
        ;; добавить проверку на чейн

        var (value, found) = storage::list_participates~udict_add_get_ref?(256, key_addr, begin_cell().store_coins(msg_value).store_slice(sender_address).end_cell());

        if ( ~ found) {
            slice payload = value.begin_parse();
            int new_bet = payload~load_coins() + msg_value;
            storage::list_participates.udict_replace_ref?(256, key_addr, begin_cell().store_coins(new_bet).store_slice(sender_address).end_cell());
        } else {
            storage::participates_number += 1; 
        }

        storage::jackpot += msg_value;
        ~dump(storage::jackpot);
        save_data();
        return ();
    }

    ;; admin part

    throw_unless(999, equal_slices_bits(sender_address, storage::admin_address));

    if (op == 1) { ;; stop game 
        storage::stop_game = in_msg_body~load_int(2);
        save_data();
        return ();
    }

    if (op == 2) { ;; stop game (нужно подумать как правильно останавливать игру если пользователи уже сделали ставку)
        storage::game_time = in_msg_body~load_uint(32); ;; sec
        save_data();
        return ();
    }

    if (op == 3) { ;; update code and data (зависит от остановки игры)
        (cell new_data, cell new_code) = (in_msg_body~load_ref(), in_msg_body~load_ref());
        set_data(new_data);
        set_code(new_code);
        return ();
    }
}


() recv_external(slice in_msg_body) impure { ;; finish and start new game
    cell msg_inner = in_msg_body~load_ref();
    ;; slice signature = in_msg_body~load_bits(512);
    ;; in_msg_body.end_parse();
    int msg_inner_hash = msg_inner.cell_hash();

    load_data();

    ;; throw_unless(7777, check_signature(msg_inner_hash, signature, storage::public_key));

    slice msg_inner_slice = msg_inner.begin_parse(); ;; parse data from ex message 
    ;; добавить децентрализацию, чтобы каждый мог запускать игру 
    int game_number = msg_inner_slice~load_uint(32);
    msg_inner_slice.end_parse();

    ;; throw_unless(111, (storage::game_start_time + storage::game_time) <= now());
    ;; throw_unless(222, game_number == storage::game_number);
    throw_if(333, storage::stop_game);

    accept_message();


    custom_randomize();
    randomize_lt();

    int r = rand(storage::jackpot);
    int flag = 0;
    int sum_bet = 0;
    ~dump(r);

    do {
        var (_, value, _) = storage::list_participates~udict_delete_get_min_ref?(256);
        ~dump(value);
        slice payload = value.begin_parse();
        sum_bet += payload~load_coins();
        ~dump(sum_bet);
        if (r < sum_bet) {
            storage::last_winner_address = payload~load_msg_addr();
            flag = -1;
        }
    } until (flag == -1);

    ;; считаем коммисиию



    storage::list_participates = new_dict();
    storage::jackpot = 0;
    storage::max_participates = 0;
    storage::game_number += 1;
    storage::game_start_time = now();
    save_data();

    ~dump(storage::last_winner_address);
}
